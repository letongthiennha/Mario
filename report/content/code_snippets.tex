\clearpage
\section{Code Snippets}

\begin{flushleft}
  This section presents representative code snippets for core mechanics and systems in the Super Mario OOP Project, aligned with the actual implementation logic from the source files.  
\end{flushleft}


\subsection*{Player Jump and Power-Up Collection}
\begin{lstlisting}[language=C++, caption={Mario Jump and Power-Up Collection}]
void PlayableCharacter::jump() {
    if (onGround) {
        velocity.y = -jumpPower;
        onGround = false;
        SoundController::getInstance().PlaySound("smw_jump.wav");
    }
}

void CollisionMediator::HandleMarioWithItem(Mario*& mario, Item*& item, CollisionInfo AtoB) {
    if (AtoB == COLLISION_NONE)
        return;

    if (item && CheckCollisionRecs(mario->getRect(), item->getRect())) {
        if (auto* mushroom = dynamic_cast<Mushroom*>(item)) {
            mushroom->collect();
            mario->setBig(true);
            mario->addScore(1000);
        }
        else if (auto* fireFlower = dynamic_cast<FireFlower*>(item)) {
            fireFlower->collect();
            mario->setFire(true);
            mario->addScore(1000);
        }
    }
}
\end{lstlisting}

\subsection*{Monster Movement and Defeat}
\begin{lstlisting}[language=C++, caption={Goomba Movement and Stomp Defeat}]
void Goomba::updateStateAndPhysic() {
    if (!isActive) return;
    velocity.x = -speed;
    position.x += velocity.x * GameClock::getInstance().DeltaTime;
    // Gravity and ground check omitted for brevity
}

void CollisionMediator::HandleMarioWithMonster(Mario*& mario, Monster*& monster, CollisionInfo AtoB) {
    if (AtoB == COLLISION_SOUTH && mario->getVelocity().y > 0) {
        mario->addScore(400);
        monster->die();
        mario->setVelocity(Vector2{mario->getVelocity().x, -600}); // Bounce
        SoundController::getInstance().PlaySound("smw_stomp.wav");
    } else {
        mario->reactOnBeingHit();
    }
}
\end{lstlisting}

\subsection*{Block Hit and Item Spawn}
\begin{lstlisting}[language=C++, caption={Question Block Hit and Item Spawn}]
void QuestionBlock::hit(Mario* mario) {
    if (state == BlockState::UNUSED) {
        state = BlockState::USED;
        spawnItem();
        SoundController::getInstance().PlaySound("smw_power-up_appears.wav");
    }
}

void QuestionBlock::spawnItem() {
    if (containsMushroom) {
        auto* mushroom = new Mushroom(position + Vector2{0, -size.y});
        Level::getInstance().addItem(mushroom);
    }
    // Other item types omitted for brevity
}
\end{lstlisting}

\subsection*{Level Update Loop}
\begin{lstlisting}[language=C++, caption={Level Update and Collision Handling}]
void Level::UpdateLevel() {
    player->updateStateAndPhysic();
    for (auto& section : monstersSection)
        for (auto* monster : section)
            monster->updateStateAndPhysic();
    for (auto& section : itemsSection)
        for (auto* item : section)
            item->updateStateAndPhysic();
    for (auto& section : blocksSection)
        for (auto* block : section)
            block->updateStateAndPhysic();

    // Collision checks
    collisionMediator.handleCollisions(player, monstersSection, itemsSection, blocksSection);
}
\end{lstlisting}

\subsection*{Resource Management (Singleton Pattern)}
\begin{lstlisting}[language=C++, caption={ResourceManager Singleton Usage}]
Texture2D& ResourceManager::getTexture(const std::string& name) {
    if (textures.count(name) == 0) {
        textures[name] = LoadTexture(("resources/Entity/" + name).c_str());
    }
    return textures[name];
}

void ResourceManager::unloadResource() {
    for (auto& pair : textures) {
        UnloadTexture(pair.second);
    }
    textures.clear();
}
\end{lstlisting}